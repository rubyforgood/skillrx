# Rules for AI

## 1. Code Quality

- **Follow Rubocop**: Always consider our Rubocop rules when writing code. If uncertain about a style or convention, check `.rubocop.yml` or existing code patterns.

## 2. Techniques & Standards

### Ruby Style

**Use Hash Value Omission**: For Ruby 3.1+ code, use hash value omission syntax when the key and value are the same.

- **BAD**: `{ instance: instance, duration: duration }`
- **GOOD**: `{ instance:, duration: }`
- **BAD**: `create(:account, instance: instance, status: status)`
- **GOOD**: `create(:account, instance:, status:)`

This applies to:

- Method arguments
- Hash literals
- Factory definitions
- Any hash where keys match variable names

**Avoid Ugly Multi-line Formatting**: When array or hash elements span multiple lines, put each element on its own line. Never create partial multi-line elements that result in awkward `,],` or `,),` patterns on the same line.

- **BAD** - partial multi-line creates ugly `,],`:

  ```ruby
  rows: [
    ['Label', format_number(value),
     format_change(value, previous),],
  ]
  ```

- **GOOD** - each element on its own line:

  ```ruby
  rows: [
    [
      'Label',
      format_number(value),
      format_change(value, previous),
    ],
  ]
  ```

- **ALSO GOOD** - single line if short enough:
  ```ruby
  rows: [
    ['Label', format_number(value), format_change(value, previous)],
  ]
  ```

Note: Trailing commas are fine (and enforced by Rubocop). The issue is the _formatting_ that creates visual clutter.

### ActiveRecord Queries

**Use Ruby Ranges**: Prefer Ruby range syntax over string comparisons for date/time and numeric ranges.

- **BAD**: `.where('created_at > ?', 1.day.ago)`
- **GOOD**: `.where(created_at: 1.day.ago..)` (Use endless range for `>=`)
- **GOOD**: `.where(created_at: ..1.day.ago)` (Use beginless range for `<=`)
- **GOOD**: `.where(created_at: ...1.day.ago)` (Use range with 3 dots for `<`)

### Exception Handling

Always specify the exception class in rescue clauses:

- **BAD**: `rescue => e`
- **GOOD**: `rescue StandardError => e`
- **BETTER**: `rescue SpecificError => e`

Let errors propagate naturally unless you have a specific reason to catch them.

### Database migrations

Always use `rails generate migration` to create new migrations. Avoid creating migration files manually to ensure proper timestamps and naming conventions.

## 3. Architecture

**No Side Effects in Models**: Avoid putting side-effects (like sending notifications or enqueuing jobs) in models. These belong in the Service Layer / Interactors.

## 4. Testing

### Validation Testing

**DO NOT** write specs that test basic ActiveRecord validations like:

- `validates :field, presence: true`
- `validates :field, uniqueness: true`
- `validates :field, numericality: true`
- Other standard Rails validations

#### Why?

- These validations are tested by Rails itself
- They add maintenance overhead without adding value
- They make specs brittle to simple model changes

#### What to test instead:

- Complex custom validations with business logic
- Validation behavior in integration/request specs
- The actual user-facing behavior that relies on validations

#### Examples:

**BAD** - Testing simple validations:

```ruby
describe Beacon do
  it { is_expected.to validate_presence_of(:api_key_digest) }
  it { is_expected.to validate_uniqueness_of(:api_key_prefix) }
end
```

**GOOD** - Testing through behavior:

```ruby
describe "POST /beacons" do
  subject(:request) do
    post beacons_url, params: { beacon: { language_id:, region_id: } }
  end

  let(:language_id) { create(:language).id }
  let(:region_id) { create(:region).id }

  it "creates a beacon" do
    expect { request }.to change(Beacon, :count).by(1)

    expect(response).to redirect_to(beacon_url(Beacon.last))
  end
end
```

**GOOD** - Testing complex custom validations:

```ruby
describe "custom validation" do
  subject(:tag_cognate) { described_class.new(tag:, cognate:) }

  context "when tag and cognate are the same" do
    let(:tag) { create(:tag) }
    let(:cognate) { tag }

    it "prevents self-reference" do
      expect(tag_cognate).not_to be_valid
      expect(tag_cognate.errors[:cognate]).to include("can't be the same as tag")
    end
  end
end
```

### Mocks and Spies

Prefer using `instance_spy` and the `expect(...).to receive` style for verification over `have_received`. This mocking style is generally more readable and separates setup from verification effectively.

Use `instance_spy` primarily when you stub the initializer to return the spy. This allows you to avoid defining the interface of a double explicitly, as spies allow any message.

**BAD**:

```ruby
let(:generator) { instance_double(Beacons::ApiKeyGenerator, call: nil) }

before do
  allow(Beacons::ApiKeyGenerator).to receive(:new).and_return(generator)
end

it "generates an API key" do
  subject.call
  expect(generator).to have_received(:call)
end
```

**GOOD**:

```ruby
let(:generator) { instance_spy(Beacons::ApiKeyGenerator) }

before do
  allow(Beacons::ApiKeyGenerator).to receive(:new).and_return(generator)
end

it "generates an API key" do
  expect(generator).to receive(:call)
  subject.call
end
```

#### For Class Methods

For class methods, set expectations directly before the action - do not use `allow` + `have_received`.

**BAD**:

```ruby
before do
  allow(FileWorker).to receive(:perform_async)
end

it "enqueues file processing job" do
  action.call

  expect(FileWorker).to have_received(:perform_async).with(
    topic.id, language.id, anything,
  )
end
```

**GOOD**:

```ruby
it "enqueues file processing job" do
  expect(FileWorker).to receive(:perform_async).with(
    topic.id, language.id, anything,
  )

  action.call
end
```

### Use Contexts for Conditional Scenarios

Always use `context` blocks to organize specs by conditions or states. This makes specs more readable and clearly separates different scenarios.

**Use `context` for:**

- Different states: `context 'when user is authenticated'`
- Different inputs: `context 'with valid params'`
- Different configurations: `context 'with feature flag enabled'`
- Error conditions: `context 'when API fails'`
- Variations: `context 'with force: true'`

**BAD**:

```ruby
describe "#call" do
  it "returns error for revoked beacon" do
    # ...
  end

  it "processes active beacon" do
    beacon.update!(revoked_at: nil)
    # ...
  end

  it "sends notification when provider is present" do
    # ...
  end
end
```

**GOOD**:

```ruby
describe "#call" do
  context "with revoked beacon" do
    let(:beacon) { create(:beacon, :revoked) }

    it "returns an error without processing" do
      # ...
    end
  end

  context "with active beacon" do
    let(:beacon) { create(:beacon) }

    it "processes the request" do
      # ...
    end

    it "associates topics with beacon" do
      # ...
    end
  end

  context "when file generation fails" do
    before do
      allow(XmlGenerator::SingleProvider).to receive(:call).and_raise(StandardError)
    end

    it "captures exception and returns error" do
      # ...
    end
  end
end
```

**Benefits:**

- Clear separation of different scenarios
- Easier to locate specific test cases
- Better test organization and readability
- `let` blocks can be scoped to specific contexts

### Side-Effect Records in Before Blocks

When creating records that exist only for their side effects (not directly referenced in tests), use `before` blocks instead of `let!`. This keeps `let` blocks clean and focused on records that are actually referenced.

**BAD** - Creating side-effect records in `let!`:

```ruby
let!(:provider_with_topics) do
  provider = create(:provider)
  create(:topic, provider:, state: :archived)
  provider
end
```

**GOOD** - Separate the side-effect into a `before` block:

```ruby
let!(:provider) { create(:provider) }

before do
  create(:topic, provider:, state: :archived)
end
```

**Why?**

- `let` blocks should return the record they're named after
- Side effects hidden inside `let` blocks are harder to understand
- `before` blocks clearly signal "setup that happens before tests"
- Makes test data setup more explicit and readable

## 5. Workflow

- **Run DB migrations**: Make sure to always run any pending database migrations with `rails db:migrate RAILS_ENV=test` command before running tests.
- **Run Verification**: Once a chunk of work is completed, always run both Rubocop checks and relevant tests to ensure no regressions or style violations.
